---
layout: post
title: C++ 문법 정리
color: rgb(242,85,44)
tags: [twitter,clone]
---
참고 : 씹어먹는 C++

C
장점 : 함수를 사용하여 개별 프로그래밍. 이식성 O, 최적화용이(리소스 관리)
단점 : 

C++
장점 : 
단점 : 컴파일 오류, 복잡한 템플릿 문법, 값 카테고리


<iostream> 표준 입출력에 필요한 것들을 포함.

namespace 이름공간
:객체가 속한 곳
`std::cout`에서 std는 이름공간
`using namespace std;`로 `std::`를 생략할 수 있다.

header1.h

### 참조자 reference

- 다른 변수나 상수를 가리키는 방법
- 포인터처럼 &와 *가 필요없어 코드가 간결하다.

```c++
#include <iostream>
int main() {
int a = 3;
int& another_a = a; //참조자 정의
another_a = 5;

std::cout << "a : " << a << std::endl; //5
std::cout << "another_a : " << another_a << std::endl;//5
return 0;
}
```
- another_a는 a의 또다른 이름이다
- another_a에 어떠한 작업을 수행하든 a에 수행하는 것과 같다.
<br>
<br>


참조자는 하나의 별명만 될 수 있다.
```c++
int b = 3;
another_a = b; //a에 b값을 할당하는것과 같다.
```


하나를 바꾸면 모두 바뀐다.
```c++
#include <iostream>
int main() {
int x;
int& y = x;
int& z = y; // z와 y는 모두 x의 참조자

x = 1;
std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl; // x : 1 y : 1 z : 1
y = 2;
std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl; // x : 2 y : 2 z : 2
z = 3;
std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl; // x : 3 y : 3 z : 3
}
```


상수에 대한 참조자
```c++
int main() {
int &ref = 4;
std::cout << ref << std::endl; //컴파일 오류

const int &ref = 4; //가능
int a = ref; // a=4와 같다.

}
```

- 레퍼런스의 레퍼런스,레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다.
```c++
int a, b;
int& arr[2] = {a, b};
```

- 배열의 레퍼런스는 존재할 수 있다.
```c++
int arr[3] = {1, 2, 3};
int(&ref)[3] = arr;
```
- ref[0] 부터 ref[2] 가 각각 arr[0] 부터 arr[2] 의 레퍼런스가 된다.
<br>
<br>


`std::cin >> user_input;` 에서 user_input은 참조자
<br>
<br>
<br>
<br>


int& function(int& a) {
a = 5;
return a;
}
int main() {
int b = 2;
int c = function(b);
return 0;
}


## 동적 메모리 할당

new와 delete
```c++
#include <iostream>

int main() {
    int* p = new int; // int 크기의 공간을 할당하여 그 주소값을 p 에 집어 넣음
    int *list = new int[5];
    *p = 10;
    std::cout << *p << std::endl; //10
    delete p;
    delete[] list;
    return 0;
}

```

## 클래스와 객체
```c++
#include <iostream>

class Animal {
    private: // 없어도 private
    int food;
    int weight;

    public:
    void set_animal(int _food, int _weight) {
    food = _food;
    weight = _weight;
    }

    void increase_food(int inc) {
    food += inc;
    weight += (inc / 3);
    }

    void view_stat() {
    std::cout << "이 동물의 food : " << food << std::endl;
    std::cout << "이 동물의 weight : " << weight << std::endl;
    }
}; 

int main() {
    Animal animal; //Animal클래스의 인스턴스 animal
    animal.set_animal(100, 50);
    animal.increase_food(30);
    animal.view_stat();
    return 0;
}
```

![](../assets/img/ios.jpg)